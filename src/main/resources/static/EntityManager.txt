1. Entity Manager와 DB 동기화 우선순위

    (1) @Transactional이 commit을 할 경우
    (2) flush() method 사용
    (3) 복잡한 JPQL을 실행할 경우


2. Cache를 사용하는 경우와 그렇지 않은 경우

    - 기존 JPARepository가 제공하는 CRUD(id값을 이용함)를 이용할 경우 Cache를 사용한다.
    - JPARepository를 상속받아 네이밍 규칙을 이용하여 쿼리메서드를 직접 만든 경우
      Cache를 사용하지 않는다.



3. 생명주기

        entityManager.persist(user);    // 비영속성 -> 영속성
        entityManager.detach(user);     // 영속성 -> 준영속성 (영속성에서 제외하고 꺼내옴)

        user.setName("newUserAfterPersist");
        entityManager.merge(user);      // 준영속성 -> 영속성


        entityManager.flush();      // clear사용시 flush사용을 권고
        entityManager.clear();      // detach 상태 : clear, close도 있음, 변경 예약이 예정되있던 사항도 모두 drop 시킴

        User user1 = userRepository.findById(1L).get();
        entityManager.remove(user1); // 영속성 상태인 entity에서만  동작

        entityManager.clear();  // remove까지 예약포함



4. Transactional Exception

    - 선택적 Exception
        (1) RuntimeException을 상속받지 않은 Exception
        (2) 반드시 try/catch or throws로 예외 처리를 해야한다. 안하면 컴파일 조차 안된다.

    - 선택적 Exception : Roll-Back 처리가 안됨
    - Runtime Exception : Roll-Back 처리함

    - 선택적 Exception도 Roll-Back시키는 방법
        @Transactional(rollbackFor = {Exception.class})

    - Bean Class 내부에서 내부를 호출할때는 @Transactional 효과가 없다.
        @Transactional이 달리지 않은 메서드에서 @Transactional이 달린 메서드를 호출하여
        RuntimeException이 일어났음에도 commit이 되었다.


5. @Transactional isolation


    (0) Lock에 대한 정리

        A 트랜잭션이 수정, 삭제의 경우 commit / roll-back 을 하기 전까지 자원을 소유하고 있다.
        이 떄 B 트랜잭션이 A가 소유한 자원에 접근하여 수정, 삭제를 시도하게 되면 자원을 할당(commit / roll-back)
        받기 전까지 Lock 상태에 걸리게 된다.


    (1) BookServiceTest MYSQL 테스트 쿼리 ( Debug에서 Test코드 실행 후 sql문 실행)
        start transaction;
        update book set category = 'none'
        commit; / rollback;


    (2) isolation (독립, 격리)
        동시에 발생하는 트랜잭션에 대해 데이터 접근에 대한 설정
        Level이 높을 수록 격리단계가 높으며 데이터의 정확성을 보장해주는 대신에 동시처리 능력이 떨어짐


    (3) Isolation Value
        - DEFAULT
            DBMS Isolation 정책을 따른다.

        * READ_UNCOMMITTED (Level 0)
            - 다른 Transaction이 commit을 하지 않아도 변경된 값을 불러온다.(Dirty Read)

            - 다른 Transaction이 rollback을 하게 되면 rollback 된 값이 반영되지 않고 변경된 값이 그대로 들어감
                -->이는 Entity에 값이 이미 저장이 되었기 때문
                --> Entity에 @DynamicUpdate 추가로 해결 가능 --> update에 필요한 field만 사용


        * READ_COMMITTED (Level 1)
            - 다른 Transaction이 commit을 하여 변경된 내용을 바로 반영한다.
            - READ_UNCOMMITTED 에서 Roll-Back 을 시킨 상황을 해결
            - JPA에서는 EntityManager Cache 기능에 의하여 반영이 안됨
                --> entityManager.clear() 를 이용하여 cache를 지워줌
            - 작업을 수행할 떄 원치 않게 데이터가 변경될 수 있음(UNREPEATABLE_READ)
                ---> REPEATABLE_READ 가 해결


        * REPEATABLE_READ (Level 2)
            - MYSQL의 기본정책, Transaction이 진입하였을때의 DB 상태를 계속 유지
                --> Transaction 이 시작할때에 조회했던 데이터를 별도로 저장(snap-shot)
                --> 데이터 베이스의 모든 데이터를 스냅샷 하는 것인지를 모르겠음...
            - Transaction 내에서 같은 값을 불러오더라도 데이터는 변하지 않는다.
            - Phantom read 현상 발생
                --> A 트랜잭션이, B트랜잭션이 동시에 작업을 수행하며
                --> B가 insert, commit 작업을, 이후 A는 update 작업을 수행
                --> B가 insert 한 데이터까지 update에 영향을 받음
                --> 한 트랜잭션 안에서 일정 범위의 레코드를 두번 이상 읽을 때,
                    첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
                    이는 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타나는 현상임.
                --> SERIALIZABLE이 이를 해결



        * SERIALIZABLE (Level 3)
            - 기본적으로 REPEATABLE_READ에 insert를 허용하지 않는 수준
            - 상대측에서 먼저 자원을 사용하다면 commit 할때까지 대기
            - 내 쪽에서 자원을 사용하고 있고 상대측에서 자원을 원한다면 내 쪽에서 commit 할때까지 대기
            - 즉 자원 독점


6. @Transactional propagation

    - 트랜잭션의 전파
jpa 에서 트랜잭션의 시작과 끝은 메서드의 처음과 끝
isolationTest의 경우 다른 클래스의 메서드를 호출
현재 있는 트랜잭션과 또다른 클래스의 트랜잭션의 교통정리가 필요(lock으로 인한 지연현상이 생길 수 있음)



propagation : REQUIRED, REQUIRES_NEW 만 알면되고 왠만하면 안건든다


REQUIRED
만약 기존의 사용을 하던 트랜잭션이 있다면 그 트랜잭션을 사용 없다면 새로운 트랜잭션을 생성하여 사용, default 값
userRepository.save()를 사용시 메서드에 @Transactional이 선언 되어있으면 메서드의 트랜잭션을
선언 안되있으면 save의 트랜잭셔을 사용한다.

SUPPORTS
호출하는 쪽에서 트랜잭션이 있다면 해당 트랜잭션을 사용하겠다(REQUIRED와 비슷)
단 없다면 트랜잭션을 생성하지 않는다



MANDATORY
필수적으로 트랜잭션이 존재해야함, 없으면 오류 발생

REQUIRES_NEW
무조건 새로운 트랜잭션을 생성한다. 호출하는 쪽의 commit / rollback과는 상관없이 자체적으로 작업을 수행



NOT_SUPPORTED
호출하는 쪽에서 트랜잭션을 가지고 있으면 잠시 멈춤 트랜잭션과는 별개로
해당 영역은 트랜잭션 없이 동작하도록 별개로 설정
호출하는 쪽의 트랜잭션은 호출받는쪽의 로직이 끝난 후 실행

NEVER
트랜잭션이 없어야 한다, 존재한다면 오류가 발생


NESTED --> 실제로는 별다른 설정 없이 JPA에서 사용 불가능
REQUIRES_NEW와 비슷
별도의 트랜잭션을 생성하는 것이 아니라 호출하는 쪽의 트랜잭션을 재활용
하나의 트랜잭션이지만 생성은 하는 것은 아닌데 개별적(분리적으로)

호출되어지는 쪽의 트랜잭션이 실패하게 되면 해당 부분문 롤백하고 호출 하는쪽의 트랜잭션은 커밋
호출되어지는 쪽이 성공하고 호출 하는 쪽의 트랜잭션이 실패해면 모두 ROLLBACK

종속적이며 상위에 영향을 주지 않는다
SAVE POINT라는 개념이 사용 : SAVE POINT까지의 성공은 보장한다



클래스 트랜잭션 < 메소드 트랜잭션