*** Table ****
@Table(name="user", indexes = {@Index(columnList = "name")}, uniqueConstraints = {@UniqueConstraint(columnNames = {"email"})})


*** Primary Key ***
@Id
@GeneratedValue // 자동으로 증가하는 숫자값
 // Auto : system index
 // IDENTITY : MYSQL  --> commit안하면 나중에 빠진 index가 생김 , 테이블 마다 인덱스이며 AUTO_INCREMENT한다
// SEQUENCE : ORACLE


****Entity Listener ****
@EnableJpaAuditing 
	-프로젝트 Application에서의 annotation
	-스프링의 기본 Entity Listener를 사용
	- EntityListeners에 AuditingEntityListener.class 추가
	- 이후 필드에 @CreatedDate, @LastModifiedDate등 사용

@PrePersist
	- insert method가 실행되기 전
	- GeneratedValue : IDENTITY인 경우 insert가 되는 동시에 primary key id값이 입력
	- 해당 메서드에서 primary key를 참조하게 되면 null값이 참조된다.
@PreUpdate
@PostPersist // insert method가 실행된 후
@PostUpdate
@PreRemove
@PostRemove
@PostLoad // select문이 실행된 이후


*** Column ***
@Column(updatable = false)
@Column(nullable = false)
@Column(insertable = false)
@Transient // 영속성 처리에서 제외됨 : DB에는 반영X
@Enumerated(value = EnumType.STRING)







*** 1:1 Relation  (Book <-> BookReviewInfo) ***
@OneToOne(optional = false)
 left outer join(합집합) --> 값이 존재하지 않을 수 있기 때문

@OneToOne(optional = true)
inner join(교집합) --> 값이 존재한다는 것을 확신 --> not null


@OneToOne(mappedBy = "book")
	- 관계를 소유하는 필드입니다. 이 요소는 연결의 역방향(소유자가 아님)에서만 지정됩니다.
	- 연관키를 해당테이블에서 가지지 않게 된다. --> 객체에서는 살아있음
	- book에 BookReviewInfo 정보를 insert하지 않아도 book에서도  BookReviewInfo 참조 가능
	- 이 경우 toString이 순환참조를 하게 되어 stackOverflow ---> @ToString.Exclude로 해결


@ToString.Exclude
toString을 생성할때 해당 필드를 제외






*** 1:N Relation (User <-> UserHistory) ***
@OneToMany
 private List<UserHistory> userHistories = new ArrayList<>();  // NullPointerException 방지, 안해도 문제는 없긴 함


@OneToMany(fetch = FetchType.EAGER)
	- LazyInitializationException 해결
	- 이유는 Transaction떄 설명


@JoinColumn :
    - 중간 mapping table이 생기는 것을 해결
    - Entity가 어떠한 column으로 join을 할 것인지 지정

    create table user_user_histories (
           user_id bigint not null,
            user_histories_id bigint not null
        )

    - mapping table이 사라지면서 user_history에 user_histories_id 라는 column이 생성
    - JoinColumn의 default 값이 해당 field에 맞는 column명을 찾아 매칭(없으면 생성)


@JoinColumn(name="user_id")
    - UserHistory의 user_id와 join 할 것을 지정
    - Table [user_history] contains physical column name
        [user_id] referred to by multiple logical column names: [user_id],[userId]
    - 논리적 모호성을 해결하기 위해 @Column(name="user_id")를 UserHistory에도 작성


@JoinColumn(name = "user_id", insertable = false, updatable = false)
    - history라는 특징 상 User에서 수정, 삭제가 불가능 해야 한다.
    - 즉 readOnly 설정을 해야한다.




