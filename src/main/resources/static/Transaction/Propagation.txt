*** @Transactional propagation ***

    - 트랜잭션의 전파
    - JPA 에서 트랜잭션의 시작과 끝은 메서드의 처음과 끝
    - BookServiceTest.isolationTest의 경우 다른 클래스의 메서드를 호출
    - 현재 있는 트랜잭션과 또다른 클래스의 트랜잭션의 교통정리가 필요
    - propagation : REQUIRED, REQUIRES_NEW 만 알면되고 왠만하면 안건든다
    - @Transactional Scope : 클래스 트랜잭션 < 메소드 트랜잭션

    (1)REQUIRED
        - 만약 기존의 사용을 하던 트랜잭션이 있다면 그 트랜잭션을 사용, 없다면 새로운 트랜잭션을 생성하여 사용, default 값
        - userRepository.save()를 사용시 메서드에 @Transactional 이 선언 되어있으면 메서드의 트랜잭션을 선언 안되있으면 save의 트랜잭션을 사용한다.

    (2)REQUIRES_NEW
        - 무조건 새로운 트랜잭션을 생성한다.
        - 호출하는 쪽의 commit / rollback 과는 상관없이 자체적으로 작업을 수행

    (3)NESTED
        - 실제로는 별다른 설정 없이 JPA에서 사용 불가능, REQUIRES_NEW와 비슷하면서도 다름
        - 별도의 트랜잭션을 생성하는 것이 아니라 호출하는 쪽의 트랜잭션을 재활용
            --> 하나의 트랜잭션이지만 생성은 하는 것은 아닌데 개별적(분리적으로)
        - 종속적이며 상위에 영향을 주지 않는다
            --> 호출받는 쪽의 트랜잭션이 실패하게 되면 해당 부분은 Roll-Back 하고 호출 하는쪽의 트랜잭션은 Commit
            --> 호출받는 쪽이 성공하고 호출 하는 쪽의 트랜잭션이 실패해면 모두 ROLLBACK
        - SAVE POINT라는 개념이 사용
            --> SAVE POINT까지의 성공은 보장한다

    (4)SUPPORTS
        - 호출하는 쪽에서 트랜잭션이 있다면 해당 트랜잭션을 사용한다.
        - 단, 없다면 트랜잭션을 생성하지 않는다

    (5)NOT_SUPPORTED
        - 호출하는 쪽에서 트랜잭션을 가지고 있으면 트랜잭션과는 별개로 잠시 멈춤
        - 해당 영역은 트랜잭션 없이 동작하도록 별개로 설정
        - 호출하는 쪽의 트랜잭션은 호출받는쪽의 로직이 끝난 후 실행

    (6)MANDATORY
        필수적으로 트랜잭션이 존재해야함, 없으면 오류 발생

    (7)NEVER
        트랜잭션이 없어야 한다, 존재한다면 오류가 발생